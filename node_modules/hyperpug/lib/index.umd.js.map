{"version":3,"sources":["src/indent.ts","src/tokenize.ts","src/h.ts","src/index.ts","browser.ts"],"names":[],"mappings":"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","file":"index.umd.js","sourceRoot":"..","sourcesContent":["export function getIndent (s: string) {\n  const indents: number[] = []\n  for (const r of s.split('\\n')) {\n    if (r.trim()) {\n      const m = /^ */.exec(r)\n      if (m) {\n        indents.push(m[0].length)\n      }\n    }\n  }\n\n  if (indents.length === 0) {\n    indents.push(0)\n  }\n\n  return Math.min(...indents)\n}\n\nexport function stripIndent (s: string) {\n  const indent = getIndent(s)\n  return s.split('\\n').map((r) => r.substr(indent)).join('\\n')\n}\n","export function tokenize (s: string): {\n  key: string\n  dict: string\n  suffix: string\n  content: string\n} {\n  let key = ''\n  let dict = ''\n  let suffix = ''\n  let content = ''\n\n  let wasInsideBracket = false\n  let wasExitBracket = false\n  let wasEndOfKey = false\n\n  const bracketStack: string[] = []\n\n  for (const c of s.split('')) {\n    if (c === '(') {\n      bracketStack.push(c)\n      wasInsideBracket = true\n\n      continue\n    } else if (c === ')') {\n      bracketStack.pop()\n      if (bracketStack.length === 0) {\n        wasExitBracket = true\n      }\n\n      continue\n    }\n\n    if ([' ', ':'].includes(c)) {\n      wasEndOfKey = true\n    }\n\n    if (!wasInsideBracket) {\n      if (wasEndOfKey) {\n        content += c\n      } else {\n        key += c\n      }\n    } else if (!wasExitBracket) {\n      dict += c\n    } else {\n      content += c\n    }\n  }\n\n  if ([':', '.'].some((el) => content.startsWith(el))) {\n    suffix = content[0]\n    content = content.substr(1)\n  }\n\n  if ([':', '.'].some((el) => key.endsWith(el))) {\n    suffix = key[key.length - 1]\n    key = key.substr(0, key.length - 1)\n  }\n\n  content = content.trim()\n\n  return {\n    key,\n    dict,\n    suffix,\n    content,\n  }\n}\n","export function encodeInnerHTML (s: string) {\n  const map: Record<string, string> = {\n    '<': '&lt;',\n    '>': '&gt;',\n  }\n  return s.split('').map((c) => map[c] || c).join('')\n}\n\nexport const h = (name: string, eqdict: string, children: string | string[]) => {\n  const childrenNodes = typeof children === 'string' ? [encodeInnerHTML(children)] : children\n\n  eqdict = ' ' + eqdict\n\n  const classes: string[] = []\n  name = name.replace(/\\.[^'\"#.]+/g, (p0) => {\n    classes.push(p0.substring(1))\n    return ''\n  })\n\n  let classList = ''\n  eqdict = eqdict.replace(/\\sclass=(['\"])([^'\"]*?)\\1/g, (_full, _quote, classList_) => {\n    classList = classList_\n    return ''\n  })\n\n  classList = [classList.trim(), ...classes].join(' ').trim()\n\n  if (classList) {\n    eqdict = `class=\"${classList}\" ${eqdict}`\n  }\n\n  let id = ''\n  name = name.replace(/#[^'\"#.]+/g, (p0) => {\n    id = p0.substring(1)\n    return ''\n  })\n\n  if (id) {\n    eqdict = eqdict.replace(/\\sid=(['\"])[^'\"]*?\\1/g, '')\n    eqdict = `id=\"${id}\" ${eqdict}`\n  }\n\n  eqdict = eqdict.trim()\n\n  if (!name) {\n    name = 'div'\n  }\n\n  return `<${name}${eqdict ? ` ${eqdict}` : ''}>${childrenNodes.join('')}</${name}>`\n}\n","import { stripIndent } from './indent'\nimport { tokenize } from './tokenize'\nimport { h } from './h'\n\nexport type IHyperPugFilter = (s: string) => string\n\nexport interface IHyperPugFilters {\n  [name: string]: IHyperPugFilter\n}\n\nexport default class HyperPug {\n  private filters: IHyperPugFilters\n\n  constructor (filters: IHyperPugFilters = {}) {\n    this.filters = filters\n  }\n\n  public parse (s: string): string {\n    return this.precompile(s).join('')\n  }\n\n  private precompile (s: string): string[] {\n    let key = ''\n    let childrenRows: string[] = []\n    const nodes: string[] = []\n\n    let isInFilter = false\n\n    for (const r of stripIndent(s).split('\\n')) {\n      if (!r[0] || (r[0] && r[0] !== ' ')) {\n        isInFilter = false\n      }\n\n      if (/\\S/.test(r[0] || ' ') && !isInFilter) {\n        if (r[0] === ':') {\n          isInFilter = true\n        }\n\n        if (key) {\n          nodes.push(this.generate(key, childrenRows))\n          childrenRows = []\n        }\n\n        key = r\n        continue\n      }\n\n      childrenRows.push(r)\n    }\n\n    if (key) {\n      nodes.push(this.generate(key, childrenRows))\n    }\n\n    return nodes\n  }\n\n  private generate (key: string, childrenRows: string[]) {\n    const c = childrenRows.join('\\n')\n    const children = c ? this.precompile(c) : undefined\n\n    if (key[0] === ':') {\n      return this.buildH(key, '', stripIndent(c))\n    }\n\n    let attrs: string = ''\n\n    if (key[0] === ':') {\n      return this.buildH(key, attrs, stripIndent(c))\n    }\n\n    const { key: k1, dict, suffix, content } = tokenize(key)\n\n    if (dict) {\n      attrs = dict\n    }\n\n    if (suffix === '.') {\n      return this.buildH(k1, attrs, stripIndent(c))\n    } else if (suffix === ':') {\n      return this.buildH(k1, attrs, this.precompile(content))\n    }\n\n    return this.buildH(k1, attrs, content || children || [])\n  }\n\n  private buildH (key: string, attrs: string, children: string | string[]) {\n    if (key[0] === ':') {\n      const filterName = key.substr(1)\n      const fn = this.filters[filterName]\n      if (!fn) {\n        throw new Error(`Filter not installed: ${filterName}`)\n      }\n\n      if (typeof children !== 'string') {\n        throw new Error(`Nothing to feed to filter: ${filterName}`)\n      }\n\n      return h('div', '', [fn(children)])\n    }\n\n    try {\n      return h(key, attrs, children)\n    } catch (e) {\n      return h('div', attrs, children)\n    }\n  }\n}\n","import HyperPug from './src'\nObject.assign(window, { HyperPug })\n"]}