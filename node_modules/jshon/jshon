#!/usr/bin/env node
// Generated by CoffeeScript 1.3.3
(function() {
  var arg, args, argv, byvalue, cont, debug, dodebug, dosort, err, file, fs, inplace, json, jsonp, length, out, quiet, run, sort, type, version;

  fs = require('fs');

  version = '20121031';

  args = [];

  file = '-';

  jsonp = false;

  sort = false;

  quiet = false;

  dodebug = false;

  byvalue = false;

  cont = false;

  inplace = false;

  err = function(str) {
    if (!quiet) {
      return process.stderr.write(str + "\n");
    }
  };

  out = function(str) {
    return process.stdout.write(str + "\n");
  };

  debug = function(str) {
    if (dodebug) {
      return console.log(str);
    }
  };

  type = function(it) {
    switch (typeof it) {
      case "number":
        return "number";
      case "string":
        return "string";
      case "boolean":
        return "bool";
      default:
        if (it instanceof Array) {
          return 'array';
        } else if (it === null) {
          return 'null';
        } else {
          return 'object';
        }
    }
  };

  length = function(it) {
    var my_type;
    my_type = type(it);
    switch (my_type) {
      case "array":
        return it.length;
      case "object":
        return (Object.keys(it)).length;
      default:
        err("parse error: type '" + my_type + "' has no length");
        return process.exit(1);
    }
  };

  dosort = function(it) {
    var key, my_type, _i, _len, _ref;
    my_type = type(it);
    switch (my_type) {
      case "array":
        return it.sort();
      case "object":
        out = {};
        _ref = (Object.keys(it)).sort();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          out[key] = it[key];
        }
        return out;
      default:
        return it;
    }
  };

  argv = process.argv;

  argv.shift();

  argv.shift();

  while (argv.length > 0) {
    arg = argv.shift();
    switch (arg) {
      case '-P':
        jsonp = true;
        break;
      case '-S':
        sort = true;
        break;
      case '-Q':
        quiet = true;
        break;
      case '-D':
        dodebug = true;
        break;
      case '-V':
        byvalue = true;
        break;
      case '-C':
        cont = true;
        break;
      case '-I':
        inplace = true;
        break;
      case '-F':
        file = argv.shift();
        break;
      case '-t':
        args.push(['type', null]);
        break;
      case '-l':
        args.push(['length', null]);
        break;
      case '-k':
        args.push(['keys', null]);
        break;
      case '-u':
        args.push(['unstring', null]);
        break;
      case '-p':
        args.push(['pop', null]);
        break;
      case '-a':
        args.push(['across', null]);
        break;
      case '-s':
        args.push(['string', argv.shift()]);
        break;
      case '-n':
        args.push(['nonstring', argv.shift()]);
        break;
      case '-e':
        args.push(['extract', argv.shift()]);
        break;
      case '-i':
        args.push(['insert', argv.shift()]);
        break;
      case '-d':
        args.push(['delete', argv.shift()]);
        break;
      case '--version':
        process.stdout.write("" + version + "\n");
        process.exit(0);
        break;
      default:
        err("jshon: invalid option -- '" + arg + "'");
        err("Valid: -[P|S|Q|V|C|I] [-F path] -[t|l|k|u|p|a] -[s|n] value -[e|i|d] index");
        process.exit(1);
    }
  }

  run = function(stack) {
    var el, it, k, remaining, top, v, _i, _len;
    while (args.length > 0) {
      debug("# args:" + (JSON.stringify(args)) + " stack:" + (JSON.stringify(stack)));
      arg = args.shift();
      if (!(arg[0] === 'string' || arg[0] === 'nonstring')) {
        it = stack.pop();
      }
      if (it === void 0 && arg[1] === null) {
        out("internal error: stack underflow");
        process.exit(1);
      }
      switch (arg[0]) {
        case 'type':
          out(type(it));
          break;
        case 'length':
          out(length(it));
          break;
        case 'keys':
          switch (type(it)) {
            case "object":
              stack.push(Object.keys(it));
              break;
            default:
              err("parse error: type " + (type(it)) + " has no keys");
          }
          break;
        case 'unstring':
          out("" + it);
          break;
        case 'pop':
          void 0;
          break;
        case 'across':
          remaining = args;
          args = [];
          switch (type(it)) {
            case 'array':
              for (_i = 0, _len = it.length; _i < _len; _i++) {
                el = it[_i];
                stack.push(el);
                args = args.concat(remaining);
              }
              break;
            case 'object':
              for (k in it) {
                v = it[k];
                stack.push(v);
                args = args.concat(remaining);
              }
              break;
            default:
              err('parse error: type not mappable');
              process.exit(1);
          }
          break;
        case 'string':
          stack.push(arg[1]);
          break;
        case 'nonstring':
          switch (arg[1]) {
            case 'true':
              stack.push(true);
              break;
            case 'false':
              stack.push(false);
              break;
            case 'null':
              stack.push(null);
              break;
            case 'array':
              stack.push([]);
              break;
            case 'object':
              stack.push({});
              break;
            default:
              err("parse error: illegal nonstring, \"" + argv[1] + "\"");
              process.exit(1);
          }
          break;
        case 'extract':
          switch (type(it)) {
            case 'array':
            case 'object':
              stack.push(it[arg[1]]);
              break;
            default:
              err("parse error: type '" + (type(it)) + "' has no elements to extract");
              process.exit(1);
          }
          break;
        case 'insert':
          top = stack.pop();
          switch (type(top)) {
            case 'array':
            case 'object':
              if (arg[1] === 'append') {
                top.push(it);
              } else {
                top[arg[1]] = it;
              }
              stack.push(top);
              break;
            default:
              err("parse error: type '" + (type(it)) + "' has no elements to extract");
              process.exit(1);
          }
          break;
        case 'delete':
          delete it[arg[1]];
          stack.push(it);
      }
    }
    if (stack.length > 0) {
      if (inplace && file !== '-') {
        fs.writeFile(file, JSON.stringify(dosort(stack.pop())));
      } else {
        out(JSON.stringify(dosort(stack.pop())));
      }
    }
    return process.exit(0);
  };

  if (file === '-') {
    if (process.stdin.isTTY) {
      err("warning: nothing to read");
      run([]);
    } else {
      debug("# reading from STDIN");
      json = "";
      process.stdin.resume();
      process.stdin.setEncoding('utf8');
      process.stdin.on('data', function(chunk) {
        return json += chunk;
      });
      process.stdin.on('end', function() {
        if (json.length > 0) {
          return run([JSON.parse(json)]);
        } else {
          err("warning: nothing to read");
          return run([]);
        }
      });
    }
  } else {
    debug("# reading from file '" + file + "'");
    fs.readFile(file, 'utf8', function(err, data) {
      if (err) {
        throw err;
      }
      return run([JSON.parse(data)]);
    });
  }

}).call(this);
